Hello, everyone, and welcome to another episode of Learn With Jason. We're doing a special Wednesday edition because my schedule is a nightmare. Today on the show, we got Ado Kukic. Thank you so much for hanging out with us. How are you doing, man? I'm doing well. How are you, Jason? I'm doing well. So, we have done this before. This is not your first rodeo on Learn With Jason, but it's been a minute. So, the last time you were here, you were at Auth0. We were talking about authentication. That's what not we're doing today. Instead, we're talking about something else. So, for those of us who haven't caught up with you from the previous show or aren't familiar with your work, do you want to give us a little background on yourself. Sure thing. My name is Ado Kukic. I work as the Lead Developer Advocate at MongoDB right now. My life centers around MongoDB databases. I try to help developers understand if MongoDB is the right solution for them. If it is, how to get the most out of it it's a really fun job. I love talking to developers. I love doing live streams, videos, YouTube, all that good stuff. I love being on Learn With Jason. Yeah, I'm happy to have you back. Today's going to be fun. I'm excited about today because it tackles something that I think is it can be one of the most intimidating parts of learning to code, and that is I want to store some data, like, I've got a form, I've got user accounts, you know, people are submitting things. Where do I put that? How do I make that secure? How do I make sure that I can read and write from that? And, like, historically, and I think this is intimidating for good reason, because if you see the vast majority of, like, big public fiascos that companies are facing right now are around data leaks. Which means they didn't lock down their data properly. Something happened. They end up exposing a bunch of people's passwords or credit card numbers or something like that. So, databases can be pretty intimidating, and I also remember from my early days in working as a developer being really intimidated by just the amount of setup that I had to do to get a database running. It was like, you know, you had this really instant on wrap with something like Mamp Or Wamp it's running Apache and My SQL, you got to get this online. What do I do? Media Temple had a setup. I don't know if it was secure. I had no idea how they were setting it up. I knew I could create a table and I was trusting my tools to have set good defaults for me. But, like, I couldn't change it or anything. So, I always felt like I was in this very weird space of, like, acting as a DBA, a database administrator, but I didn't know what I was doing, and I only sort of understood, like, performance stuff. I only sort of understood scale. And so when things got popular, my sites would just go down and I'd be like, hey, good problems, right? You know, laugh it off, because that was the best I could do, but is that really true anymore. Like, is there that much work required to get a database up on the internet now? I mean, if you are selfhosting these days, there is still that curve of, you know, how do I get this deployed? How many resources do I need? Where do I deploy? Which ports do I open to make sure that only certain hosts can connect to it? And, yeah, I mean, it is still very much a fulltime job to manage your own database. But luckily, you know, the big players in the game have stepped up and offered a lot of managed solutions. You know, so, whether you are using, you know, MySQL or MongoDB, there is a provider out there that has made a SaaS out of it where you don't have to do as much of the manual setup deployment. Making sure the configuration settings are all correct. That's all the hard stuff we at MongoDB do with Atlas. We make it simple for you to go click a few buttons, get a cluster set up to it, and redirect data. So, you know, it's a twoway street. If you wanted to manage everything yourself, you absolutely could, and it's still an uphill climb to figure out all of the settings, but the good news is, you know, in today's SaaS world, there is probably a SaaS out there that can help you out. Yeah, yeah. So, I mean, maybe this is something that's worth thinking about a little bit is... if I'm thinking about building an application and I need a database, how would you, I guess, start to make the decision? Like when is it worth it to go selfhosted and do all that extra work versus using something cloudbased and managed? Right. I mean, for me, I used to be of the opinion that I want to own and control the entire stack, whether I'm building an application, like, you know, I had a big distrust of SaaS platforms because, you know, what if tomorrow Auth0 goes down? Sure. What if X, Y, Z goes down and then my application is down. Over the last couple of years, I've really, you know, changed my thinking, and, you know, believed that the way to get your app out there fast is to utilize as many SaaS applications as possible. Like, for example, with authentication, could I code it myself? Absolutely. I think the talented engineers at Auth0 are always going to do a much, much better job than I could. They're going to think about all the edge use cases. All the data storage. Requirements. How to properly hash and secure the passwords that I, you know, have some knowledge of, but I am far from an expert. Same when it comes to databases. I would never personally try to selfhost my own database. Because, one, you're not really saving that much money, because, you know, databases are very resource intensive. Right. So, you're still going to be paying a decent amount of money, but now you've left the whole management side of it, which is a lot of hidden costs. You know, and that's actually a really good point, because, like, one of the things that I think we what you said about, like, I want to host my own thing. I want to control my own thing. I believe that for the things that I am good at. So, like, I want to build my own front end, you know? I have years of experience writing front ends, building front ends, and as a result, I know that I will do a good job on that. And that I'm usually frustrated if I try to use a tool that will do it for me. Yep. However, when I'm doing back ends, I'm not a DevOps pro. I can muddle my way through it. I've done that kind of work and I've done it successfully, but I tend to suffer less when I just let a company that specializes in that thing take control of it for me because I don't know the what happens when what are firewall rules I need to set up? I can copy/paste them out of a tutorial and hope the person who wrote the tutorial is an expert. Same thing with configuring Engine X or Apache. I don't really know how that stuff works. I know how to get it running, but I know how to get it running because I'm capable of piecing together information from tutorials around the web. I don't know the ins and outs of it. Someone who is running one of these services, they're specifically employing highly skilled people whose whole job is to know those things. Exactly. That's where I've started to land. If I'm actually the expert, I want to do it myself. I want to own my own thing. If I'm not an expert, I don't want to get that level of hubris that because I'm a really good React Dev I should somehow own my own MySQL deployment. I'm not a DBA. I'm actually quite bad at that. I've had many sites get overloaded and go down because I don't know how to scale a database. So, maybe I should just trust a professional with that. I think, for me at least, where I've started to see the tradeoff come in is you have to hit a level of scale where pennies matter. Right. Right? Because what you're talking about when you start selfhosting is you have to be making so much money off of a service that paying a team of DBAs and, like, DBAs in this current work environment are making, like, 200plus grand a year. Oh, yeah. So, are you making enough money that paying a team of DBAs $1 million a year in total comp is going to save you money? And the answer for the vast majority of us is no. Right. So, that's where my tradeoffs start to be drawn. Unless I am 100% sure that I can do a good enough job that it's not going to cost me money, I look at the economics, like, it needs to be actually worth bringing it inhouse to bring it inhouse, because otherwise, I can let a team of experts do this job for me and pay them significantly less than it would cost for me to do it inhouse, or take on a bunch of cost and headache now. It just doesn't make sense. Exactly. And, you know, when it comes to, like, you know, developers, I think a lot of us, you know, have a lot of personal projects that we work on. Small applications. And most SaaS platforms, including MongoDB Atlas, have a very, very generous free tier where you can develop your application, build the whole thing without paying a dime. And, you know, then when you're ready, when you get to that scale, if you get to that scale, then, you know, swapping it out, if you decide you need to, isn't as painful. This way you can just start coding, stop worrying about infrastructure, stop worrying about where it's hosted, just have it run. Just like serverless. You don't care where that server is hosted. Who manages it. You care when you call that endpoint, you're going to get the result you expect. Right. That's exactly it. I want to work on my idea. I don't want to work on the boilerplate and the foundational stuff that lets my idea function. I want to click a button and have that done for me. So, this is actually, I think, new for Mongo, right? Because previously, I would have needed to deploy and not selfhost, but, like, deploy Mongo to some cloud instance and configure it myself. So, is Atlas aiming to solve that problem? It's, like, a oneclick managed solution? Yeah, exactly. So, MongoDB Atlas, we actually just celebrated the fifth anniversary of the kind of managed service. Oh, so, this is not new at all? I just have not been paying attention. (Laughter) It's not super new, but it's also, you know, it's something that we at MongoDB found that, you know, a lot of people still use the community edition, the enterprise edition and host themselves. But, you know, for developers that don't want to manage databases, you know, instead of having to hire, you know, MongoDB DBAs, having a service that we can kind of compartmentalize and expand on the platform, because MongoDB these days is like with Atlas, it's so much more than just a database, you know? It has it has all sorts of different features and functionalities that build on top of the data layer, where, you know, and I'm sure we'll get into some of that as we, you know, when we get into the code, but, you know, the idea of MongoDB Atlas is it is your database back end for, you know, search or, you know, offloading the data that you, you know, that you don't need into a data lake or working with data from different, you know, in different formats, from different platforms, just kind of bringing it all into Atlas and making it your, you know, your onestopshop for all your data needs. So, that's kind of the approach we took with Atlas. Nice. And there's a question in the chat from Anthony about Atlas and Realm. So, what is the what's the relationship between Atlas and Realm? Sure. Maybe start with what Realm is because I'm actually unfamiliar with it. Sure. So, Realm is a mobile database for, like, iOS and Android applications and hybrid apps. Where Realm is a local database that lives on the device and it functions very similarly to MongoDB. And we actually acquired Realm a couple years ago. Now we have a functionality within the Atlas platform called Realm Sync that allows you to write your data to the Realm database on the device. When you're connected to the internet, to a network, you can sync that data to a MongoDB database and kind of keep all of your clients in sync. So, Realm is kind of our take on mobile databases and, you know, Realm and Realm Sync kind of integrate seamlessly into the Atlas platform. Okay. Very cool. Okay. All right. So I think any other questions that I have are going to be more easily explained by showing than telling, so why don't we switch over into pair programming mode here. And before we get too deep into things, let's do a quick shoutout to our sponsors. So, we've got Jordan from White Coat Captioning here today. Thank you so much, Jordan, for taking the time out and doing the live captioning here. We're able to afford White Coat Captioning through the support of our sponsors, Netlify, Fauna, Hasura and Auth0. All kicking in to make the sure more accessible to more people, which means a lot to me. I'm happy everyone can enjoy the show, regardless of the way you like to consume content. If you need that head over to learnwithJason.dev. Find Ado on Twitter. Make sure you get over there why am I not following you? What happened? I'm now following Ado. You should be, too. Get in there and get a follow in. And then we're going to be talking today about MongoDB and specifically I think we're going to be working in the Atlas platform. And I think, what, we're going to try to do so, let's talk a little bit about the project, right? So, what I'm interested in, because it's where I spend a lot of my time is most of the apps I build these days are using that Jamstack approach of, like, a decoupled front end and precompiling as much as possible, but I always need some dynamic thing, and I don't really want to have to spin up a whole back end server to do the one or two dynamic things in most of the apps I build need. So, I'm always using serverless functions. What I would love to see today is how can we build an app that uses MongoDB Atlas and serverless functions to do some read right? Sounds great. I think MongoDB Atlas will very easily, you know, help us solve this use case. And there's a couple of different ways we'll be able to access MongoDB, and one of them is, you know, using the MongoDB drivers directly. But we can also, you know, if we have time at the end, show that Realm functionality where we can deploy serverless functions from the Atlas platform, which is kind of exclusive to Atlas. Okay. Cool. Yeah, let's okay, so, if I want to get started, what's my first step? I hit the So, a good first step would be to try it for free. You know, we don't require a credit card or anything to get started. You just sign up for MongoDB Atlas. And then, you know, as you can see, we have multiple ways of working with it. You can, you know, deploy cloud with Atlas, onpremise, or however you want, but Atlas is the way to go, which gives you all of these additional capabilities. Okay. Give me just a second to actually how do I get this to come off the screen? Let's go over here maybe. Anyone? Will you do a okay, let me pull this off screen real quick and generate a password. Let's do a password generator. OnePassword is one of the greatest password managers there is. I love it so much. Let me find there's the password. Good. I'm agreeing. Let me pull this back over now that I've got everything back in. So, I have I've generated a password, and I've agreed to the terms of service, so I'm getting started. Mmhmm. Hopefully, I haven't created an account, like, ten years ago that I forgot about. Didn't. Here we go. I think. Okay. Verifying email. That's over on this screen. Let me do that real quick. Okay. I'm going to click this email and just gonna drop it right in here. Verified. Boom. And now we are off to the races. So, we have a we have this kind of onboarding experience that allows you to set up your account really quickly, so it's just a couple of couple of fields. That are that'll get us started. I use JavaScript. Okay. Set up my project name. So, on this screen, this is kind of where we can where you can choose what type of database you want to deploy. And we recently previewed our serverless offering as well that allows you to create instances and have them scale automatically for you. So, you can use it, but, you know, what I recommend for now is that we use the free shared cluster, which is going to get us through which is going to get us started, and you can always change your instances, you know, as your application grows, but from here, you just, you know, you can leave all of the defaults selected or change them as you want, but from here Let's move them close to me so that things are as fast as possible today. Nice. So, that's going to the free cluster gives you 512 megabytes of storage. It's free forever. 512 megabytes is going to go a long way unless we're storing files, right? Oh, yeah. And then do I need let's see. So, I'm not going to do a backup since this isn't production data. Do I need to set a cluster name? No, cluster 0 works just fine. Okay. And with the free tier, so, recently, we released MongoDB 5.0. On the free clusters, it's still MongoDB 4.4. But that really doesn't make too much of a difference for our purposes in this. But MongoDB 5.0, if you are using it for productionlevel workloads, it adds a couple of really nice features to make your experience better. So, it's going to take a minute or two to get the clusters set up and deployed. So, you know, now it's doing all the back end stuff Should I set up a front end while we're doing this? We can do that, yeah. Okay. So, what I'm gonna do do you have a preferred, like, is there a specific template language I should use or just stand up anything? Stand up your preference. Okay. So, I'm just going to I have a template for new projects. So, we can use this template. And we're going to put it on can I put it on Learn With Jason? I can. Let's say letslearnmongodb. We'll make this public. Create the repository. Okay. So, then I can come out here, and I'm just gonna repo clone this one. Let's move into it. Okay. So, then that, I can npm install. And then we can Netlify dev. So, this is like an we'll be able to write all plain HTML and JavaScript in here because of the way this is configured. So, no framework things. So, let's open this up. That opened in the browsers, so let's pull this over. And then let's also start this thing. I'm gonna see if opening this browser causes it to use the right browser. I don't know why, but it, like, really does not like this particular browser when I try to run local dev. It always pops open the other one. Yeah. So, this gives us our demo. If I look in my source and this index.html, it's just, like, whatever we want in here, so I can do, like, an h1 of Let's Learn Mongo. So, it's like a wrapper, right? This is basically so that we can focus on just the code we need and everything else is kind of abstracted away. Right on. So, hopefully, by now we've got a cluster. Hey! Sweet. All right. So, what's our next step here? I think the next good step would be to load some sample data into the database. Okay. This way we can, you know, instead of having to write data and kind of make a mock application, MongoDB Atlas provides a bunch of sample databases. So, if you want to click on that ellipses menu there will be a load sample databases button. This is going to load a bunch of different datasets we can work with. Hit that for now. That's also going to take about a minute to load. So, while we're waiting for that, a next good step might be to set up our database access and network access to enable our front end application to be able to connect to the database cluster. Yeah. So, the first thing we want to do is head over to database access. And in here, we can create a new database user. And just use, you know, username and password authentication as the method. For this one, you can set it to whatever you'd like. Okay. So, let's call this one so, quick question. Are we going to be doing this as, like, a readonly user and a right privileged user for kind of, like, public access and privilege access? Or are we trying to do this is there a different permissions model for Mongo? So, for this one, just by creating the default user, it's gonna give them the, you know, read and write privileges to any of the databases within the cluster. But, you know, we could fine grain it, you know, if we're building a real production application, we might want to create a database user that has, you know, scoped down permissions to only certain databases, but for right now, I think just keeping everything as default would be fine. Okay. Great. So, what I'm going to do is I just created I auto generated a password, so I'm just going to store these over here so that I don't lose them. Uhhuh. Read and write is the default. We can set it up to do all sorts of things, but we're not going to deal with that yet. Restrict access. Temporary user. Okay. So, let's add them. Cool. So, now we have a user created. The next thing would be to go into the network access tab, and by default when you deploy a cluster on MongoDB Atlas, it doesn't talk like, you can't connect to it. You have to give it access here in the network access tab. So, you know, the way to do that is to enable an IP address. And by clicking on that button, it'll give you the option of adding your current IP address or allowing access from anywhere. If you have a certain list of IPs you want to enable. I know in a lot of serverless environments, you know, where you don't know where the IP where the app is going to be deployed from, where it's going to be talking, we encourage you to set it to "allow access from anywhere," but if you do know your IP address, where the app's going to be deployed, then, you know, you can scope it down to that. Got it. Okay. So, we're using serverless. I've set it to allow access from anywhere. What we want it to do in a real database here is our user would need to probably have, like, restricted permissions to only allow writeups on things that it should be able to write. So, for example, if I'm setting up an app where I want people to be able to, like, submit posts, I would maybe give them the ability to create and modify posts, but not to delete posts. And I would want to restrict it to only modify a post that they had created themselves. And those, you know, those sorts of things that manage that. It sounds like we're probably not gonna have time to do that today, so we'll, you know, we're using sample data. We can do whatever. More production environment it sounds like we would want to get a little bit more restrictive about that. Definitely. Yeah. So, now that we have our database access. We have our user. We have our network access enabled. If we head back into the databases section, we can see if our sample data is in. And it might be. So, if you want to hit the "browse collections" button, it will take us to an inbrowser view of the collections that have already been loaded in. So, this is gonna allow us to actually view our data, and we can actually manipulate it in here as well, add new records, delete records. Nice. Okay. And it looks like it is still working. Doing its thing. I mean, you know, it's 300something megabytes that we just loaded in here. It's, you know, it's the internet. You got to give it a minute. It's going to space. Yeah, while we wait for this to load up, if you want, we can, you know, go to the front end and make a couple more changes, maybe bring in the node library for our serverless functions. Okay. Or if there's anything else you wanted to do on the front end. No, let's do it. Let's bring in the Node library for our serverless functions here. Let me make sure we've got a package JSON. Yep. That's all good. Let's make sure I got the right version of everything. I do. Okay. Yeah, so, what's what package do I need here? Sweet. So, the only package we need is MongoDB. So, it's just, you know, MongoDB. All right. Let's get it installed. And so this MongoDB package is MongoDB's official node driver. If you wanted to use an ODM, object data modeling, Mongoose is one that is really popular. For me personally, I've never been the biggest fan of ORMs or ODMs in the SQL roles. I love the Node driver itself. So, we can if you're cool with it, we can just use the builtin functionality of the driver. Yeah, okay. So, let's do this. Let's what's our first, like, just a read function? Yeah. Let's maybe get so, we were talking about maybe creating, like, an app that displays movies. And one of the sample datasets that we're loading in is going to have a bunch of movies from IMDB. So maybe, like, you know, getting a list of 20 movies. Okay. So, let's call it "getmovies," and in here, we'll just set up the basics. We will export async function handler. And we're going to 200. Body, for now let's just set OK, and that way we can verify it's working the way we want it to. So, I should be able to do I might have to add one setting so that we can use ESM here, but I think I'm just going to be able to hit this right away. So, Netlify/functions/getmovies. So, let me change the bundler here, because I want to be able to use ESM. So, I'm going to set functions. And then down here, I can set node_bundler to ES build. Let's restart it using ES build. And now there we go. So, now it's running ES build. And we can do ES things. I probably should have asked beforehand. Is MongoDB the Node package compatible I think it will be. It should be. Okay. Great. All right. So, if I want to load something up, do I need to set that username and password as environment variables? Yes. So, we're actually going to so, the first thing we'll do is bring in the MongoDB client from the MongoDB package. So we can, like, import Mongo client. Is it like a constructer? Yep. And if you want to wrap it in curly braces because it's not the default export. Gotcha. Gotcha. And then create a client library now that's going to allow us to interact with MongoDB. So, we wanted to create a client which would be, you know Did this thing just did it just do the thing? Is this all right? That is it. Man, Copilot, I don't even need to exist anymore. Look at Copilot just doing the whole job. Yep. You got the collection as well. Yeah. Okay. So, it's gonna pull up the collection of movies. Yep. So, the other thing so, we have the awaiting the so, let's see. Const db. We'll get our environment variable. I think the Mongo client is actually a constructer, so, we might want to move the await function and do new Mongo.client. We're going to pass in the environment variables. MongoDB_uri from the process. MongoDB_uri. Okay. So, oh from here, what that's gonna do, that's gonna create our client. Maybe we change the database name to "client," and then we'll call so, this is going to create a promise for us. So, we'll get back a client promise. So, if we create a new variable called client promise equals client.connect, that's going to take care of the connexion for us. Like that? Uhhuh. Okay. And then what we're gonna do to get the actual database is call now we can create, like, the const DB equals await client promise. Is this not doing that? So, that gets back to connection, and we call client promise to get the actual connection. So, we call it like that? Without the parenthesis. So, we're just getting the result of the client promise. I got you. Okay. So, from here, and one thing we also might want to do is move all three of these lines outside of the out of the function handler, because if we do run it every single time, we're going to be make a connection to MongoDB each time. I get you. That's going to introduce a lot of latency. If we introduce it outside of the function, it's going to pull the function as long as the serverless function is running, so we don't have to rerun the connection every single time. From here, we are good to connect to our collection. So, what we could do is DB I think that DB function is going to I think we might have to chain it with .db. So, maybe we could rename it to something else like "Mongo." Can I just deconstruct it like that? I don't know. We can try and see if it works. How about we how about we don't tempt fate here. So, we'll get constDB equals Mongo.db. It's a function, so we actually put the name of the database we want to use. So, now might be a good time to go back into the Atlas UI and see what our database name is called. Okay. So, let's get in here. And overview. So, then if we go back into collections, the data should be there. Thank you for the sub. Welcome to the boop crew. Make sure you can boop the heck out of everything. (Music) Why is there no sound? What has happened? Did I mute something? Can y'all hear that? Because I can't hear that. I can hear it. Oh, no, what is happening that this isn't playing for me? Well, no sound. No sound out. So, only you can hear it? Mmhmm. Oh, weird. What have I done, everyone? Does this need to go somewhere else? YAML, YAML, YAML, JSON. Why are you like this, computer? Just a second to figure out what's going on. You can do it. Come on little compooper. I wonder, well, something that I have broken. Hmm. I can hear you just fine. So, there should be noise from the stream itself. And I'm not sure why it's not doing the thing. Just refresh that and see if that makes a difference. Somebody give it a shot now. Let's see what happens. All right. Today is not the day to restart and see how it goes. So, it looks like we're having a little bit of issue with getting this data in. Let's maybe do a hard refresh of the page. It could be something funky there. Okay. I held down the button really hard, too. So, hey, look, I did it. So, we have the database we'll work with is called sample_MFlix. Got it. If we look at that database, it has three different collections, comments, movies well, actually, five different collections. And in MongoDB, like, if you're familiar with SQL, collections are, you know, can be mapped to for example, you'll see our list of movies, and currently we have 25,000 documents in here. Mmhmm. And, you know, the cool thing about no SQL in MongoDB is that instead of, you know, rows, you know, kind of flat rows, you store documents, which can be, you know, simple onetoone mappings of integers, strings. Et cetera. You can have arrays, nested objects, all sorts of different types of data, all within that single document. Nice. Nice, nice. This is handy, right? We got a lot of different stuff in here. All good. Can I I guess so, to get out here, what we need is do I need to set the Mongo database or can I just Yep. So, what we can do there is just set the database name as "sample_MFlix." I don't even know what I just shared. Sample_MFlix is the database. Okay. And then our URI is going to be So, there's a so, to get that, if we go into the Atlas UI and click on the "databases" tab, there is a handy connect button. Okay. And we'll say connect to your application. The that's going to give us the string so that MongoDB plus SRB is our string. Got it. Looks like the password is here. So, basically, we're going to set this in the URI here. So, here's what I'm going to do. I am going to take this over to my other window and put in the actual password. And then copy it. Okay. So, then what we can do is I'm going to use I'm just going to, like, Netlify init this project so that we can, you know, deploy it. And I'm going to create a new site. We'll call this letslearnmongodb. Let's see if anyone has claimed that one. They haven't, aha. Deploy the site directory. The functions folder is there. All right. So, now that I've got this, what I want to be able to do is I'm going to use this Netlify and I can actually set or unset variables. If I look at Netlify Set. Should have done help to show what the controls are. So, I can set the name of the variable and the value of the variable. I'm going to run ntl set, MONGODB_URI. Set this whole string but with the password in it. I'm going to pull that part off screen so that it's what we want. Let me get that. Okay. And now I'm setting it. And it did the thing, so I'm going to clear. And then we're going to come back. So, now when I run ntl dev, it will pull down that MongoDB URI. So, this is now in the site itself, so it's ready to deploy, but it's not in, like, I don't have to worry about, like, sharing this or anything. So, it's all it's all around. Anybody on my team can use it. And it works locally as well. But I did something wrong. Cannot use import statement outside a module. It is a module. What have we done here? Did I screw something up? Why is it trying to use CJS here? Oh, because it can't await. I see. Okay. So, we just need an async function createconnection. And this will move all of these bits into it, and then we need the let db equals, like, a I guess we can just do, like, false or something. Uhhuh. And then here, we'll just set db to be the db. And if db, we will await, createconnection, and then we'll have our database. Boom. Perfect. So, that should solve that problem. Please don't explode. Please don't explode. Yeah, okay. (Laughter) All right. So, now, we're getting this out. We've got some connexion. And then, yeah, now what happens? Way, what's up? The whole MongoDB account is here. Right on. I don't know who's running it, but thank you for stopping by. Sweet. So, now we're connected to MongoDB. We're connected to the movies collection. So, if we just want to send back, you know, a couple of movies, we can run a find operation. So, all we do is chain to the db.collection. So, we could do Like collection.find Uhhuh. And then we could just pass in an empty object, because we just want, you know, the first list of however many movies. Okay. And then if we just run this by itself, it's going to send us all 25,000 documents, and I don't think we want that. Nope. So, we can chain it with a .limit, and I think it's .limit, right? Let me make sure. Limit it to, like, five? Yeah. And then we can also do the .toarray. Which by default, if we just do the limit without the to array, it's going to send us back a curser that we'd have to manually do a for each, and convert it into an object, but that's a helpful method for that. Okay. So, I ran this, and now we got back an empty object. Which means that something I've done is wrong. Okay. So, let's But we didn't get errors, and that's always a good sign, so that points to something that I have done is not doing what we want it to. So, let's see. Sample_mflix is the collection. Legend physical. The full episode will be posted on learnwithjason.dev. You can find it actually, it's going to be in the schedule right now. This will be the permanent URL for it. Once this gets uploaded, that will be the permanent URL for this thing. All right. Let's see if we can get this thing rolling. Cool. Is there something I can console log to check health at certain points? We can console log the connection const. We're going to go over here. We're going to reload. Okay. So, then we've got it's giving us a thing, and the db is do I need to go into the db? Wait, no. Nope. You shouldn't have to. So, db sample. So, everything looks fine here. Okay. What happens if we console log the movies array as well? Okay. Let's try it again. So, we get a promise. Ah, there we go. So, we would just want to await that collection.find. Movies! Now we have movies. All right. Okay. So, this is great. And that is so, we were on the show yesterday talking about debugging and, like, the challenge of debugging serverless stuff if you have to deploy it every time. And so that is, like, this is a great example of why having a local development process for your serverless functions is so nice. Okay, console log it. See if it works. I don't have to deploy that. I don't have to create a commit history with me being, like, completely confused. Right. So, that my coworkers can screenshot it and laugh at me. That's always my favourite, is when we're working on a project and you can just see somebody's commit history where it starts out very logical. Okay, attempted fix this to fix this problem. Then it gets progressively more unhinged as they go. By the end, it's like please work. Just a commit message of question marks. Or it's like this one fixes it. Fix of a fix. Fix, fix, fix. By the end, it's like please, God. (Laughter) Happens way more often than I'd like to admit. Oh, I love it. It's so good. Okay. So, we've done it. We have now with, you know, relatively low effort here, what, like, 23 lines of code? We are running a serverless database connection and reading from a database and we're able to pull that from an environment variable. So, this is secure. We're not sharing the details anywhere. It's not being used on the client side, so nobody can grab this and use it. If we wanted to access this, you know, we could do something as simple as let's just create a script tag without that extra comma. And in here, we can, like, I don't know, let's set up a function that's, like, load movies. And in here, we can say, const res equals await. Fetch. We'll go right to this function netlify/functions/getmoves and then res.JSON. Down here, we can do something like let's put a pretag. And we can do, like, document.queryselector. Let me make this a little less terrible to read. Set it to our movies. Make it a little wider so it's actually visible what's going on. Why is that formatting so poorly? Jeez. Jeez Louise. Okay. That should be a little bit less terrible to look at. It's going to auto format for me. Watch. Are you going to help? You are. Anyways. If we go back to the index page now, though I think we had a typo in the get moves versus get movies. Oh, I also didn't getmoves and I also have to call the function. That's a critical part of writing code. So, we're going to load the movies. So, now we'll see there's our movies. Tada. Boom. So we are now officially on our page, you know, here is all in the serverless function. Nothing fancy. No real big deals that we have to do here. We're able to just dump this data right on to the page very quickly. We did all of that in a serverless function. So, what previously would have felt like a whole lot of stuff. I would have had to set up a Node server. I would have had to figure out how to configure Express or something like that. Get the connection set up so the server could contact the database. All those good things. Figure out where to put my environment variables. I would have to build and deploy a front end that talks to the back end that talks to the database to do it all securely. We just did it all in, what, 50 lines of code? Yeah. So, that, to me, is where this really, really starts to get exciting. How much can we do as front end developers without having to become experts? Like, so, let's take this a step further how would I guess, you know, I imagine you had an idea for what to do next here. So, what do you want to do next? Yeah, so I think, you know, we have that collection of 25,000 movies. And, you know, I might want to find my favorite movie to watch or learn more information about it. And I think a cool thing might be to show how we can easily add search functionality. Because I think a lot of apps, you know, search is something that many, many apps need, but it's also kind of a pain to implement and build yourself. Absolutely. So, we can show how to do that. This is a feature that's exclusive to MongoDB Atlas. So, if you're using MongoDB, you know, selfhosting and selfmanaging it, it, you know, we do have like basic search functionality, but if you wanted a really powerful search engine on your database, on your MongoDB database, Atlas Search, you know, it's under the hood so you can misspell things and still get the right results. Oh, nice. And deploying it as simple as, you know, creating a search index. So, can I, like, create searchmovies.js and we'll be able to kind of take all these bits over here and then just kind of change the way we do this part? Yep. Exactly. And probably get a search term out of the handler. Yeah, absolutely. So, you mentioned a search index. So, do we have to create that here? Yep. So, what we would do is go to the browse collections section in our cluster. We would select our database, which would be the sample_mflix. And then, let's see, in there, I think it's the "create" button. It might be go to the "movies" section. Search indexes. There is search indexes. So, if you click on that, you can by default hit the "search index" button and it's going to pop up a number of different ways you can do it. We can just use the visual editor and make the simplest index possible. And in this case, we just want it on the movies collection, and we can, you know, span it whichever database we wanted. But for now, we can just say, you know, movies, search index hit the next button. Here, we can leave all of the defaults as is. It's going to create a search index on all of the fields by default. If we were building a search application and use certain fields we didn't want search on, we could fine tune it and make it as specific as possible. But, you know, creating a general search index on everything is fine for the demo, I think. All right. Here we go. Okay. So, I've done that. I've created my search index on the sample_mflix movies collection. Is this a collection? Is it a table? What's the how do you what's the terminology here? So, this is a database name. So, the database name is sample_mflis and the sample is what holds the movies themselves. So, this is going to take a couple of minutes to spin up. While it does that, what we can do is write the code to implement our search functionality. Let's do it. So, everything that we have so far is totally fine. The only thing we'll change is that essentially the line that you commented out. And what we can do here so, there isn't in the Node driver there isn't, like, a search method. The way we would implement search is by using an aggregation pipeline. And I know you said you worked with MongoDB briefly in the past. Have you had a chance to work with MongoDB Aggregations at all? Nope. I know what aggregation means. I know what pipeline means. When you put them together, I get a little foggy. Thank you for the sub or for gifting the sub, Ben. That's very much appreciated. Nicky, spam the heck out of those boops. All right. So, when it comes to go further with your data and essentially what you can do is create a series of stages that go through a pipeline. They can either philtre your documents, they can match certain documents. You can add data to the documents that are being returned. Or any sort of, like, you know, you can even write custom JavaScript functions to transform the data however you want. Okay. And one of the aggregation functions that we have is called Search. So, what we'll do is write a search aggregation that's going to work on that search index and get us the results. Okay. So, I'm going to call it, like, "results." Mmhmm. And we'll await is it still in the collection? Yep. So, it'll be collection. and then instead of find, it's going to be aggregate. Okay. And then the aggregate takes in an array of objects, essentially an array of stages. Okay. So, stage 1 would Copilot is so great. I'm actually gonna turn it off so it stops stealing our thunder here. Let me turn it off here. Yeah. I said stop it. Let me close and reopen this again so it stops helping. Okay. That should fix it. So, here's our first pipeline here. I'm afraid I can't do that, Dave. I know. That's really what we're headed toward, right? Hey, thank you for the sub, Alan, and make sure that you spam that boop. Okay. So, if I want to write my first query, what I'm thinking is I want to be able to take in so, we'll get the event. And let's say that we're going to get the event through a query param. We'll call it search and get that out of event.queryStringparameters. That might be param. We'll find out very quickly if I'm right on that. We'll log it. We've got function search movies. So, let's go here, I'm going to say.netlifyfunctions and we'll search movies with a search I saw anvil in one of the descriptions. That should give us something. Movies wasn't defined. That's fine. We knew that was going to happen. Okay. I got it right. Boom. Nice. Let's us get the query string out. So, now I'll be able to use this search in the results. Mmhmm. And I would like to search everything for my keyword, is that right? Yep. So, the first step in this when we're creating a search aggregation, the first stage is gonna be the search aggregation itself. And all of the aggregation operators start with a dollar sign. So, in our case, it's going to be dollar sign search, and that's going to be an object. And inside of this dollar sign search aggregation, we're doing a text search. So, we're going to name the next field underneath "text," and it will be a string. Like this? I can put in my search query You can put in search query. You might have to wrap text in actual like a string. I'm totally blanking on Like make this a string? Like so? Make text a string. So, just wrap it in yeah. I think that's gonna get auto formatted away, but we'll see what happens. Okay. And then so within this text, that's actually going to be an object itself. So, instead of the search term, we can delete search and create an object. Okay. And underneath that, we'll have query, which is gonna be our search term. Got it. Okay. And then underneath here, we have to pass one more property, which is the path. And the path tells us so, the path is gonna go underneath query. Oh, gotcha. In the text object. And what the path is, it's gonna be which documents which fields in the document did we want to look at. So, we can either pass in a string or an array of strings for the different document. So, for right now, if you just wanna pass in a string of plot because I think plot is going to have the most information about a movie. Okay. We can go and change it later. Okay. So This should give me my results, and then stringify those. Now, do I need to to anything with this or is that the whole thing? We've just searched now? That should be it. I'm not sure if we'll have to write the to array. Let's see. It gave me events and events count of 0, which leads me to believe I missed a step. Let's see. Let me try the to array and see what happens. Empty array. Maybe my search string needs to be different? Let's go back here and let's look at a plot. Uhhuh. Oh, is it plot or full plot? Let's do That should have worked. Okay. That should work. So, if we go back into our Atlas cluster, maybe the search index isn't created. Oh, yeah, maybe. It says active. Query. Anvil. Awards cast, awards cast. Why is it not hitting the plot. So, if we view the query syntax Should I do wildcard? We could try that. Since there would be an object in the path. That would search all of the documents. Okay. So, let's do it's an array. Or an object. Wildcard. Like that. Let's go back out here and see if it does a thing. Oh, and then the maybe the other thing that we missed is adding the index name. If we go back into the Atlas UI, it had the Oh, right. Because I think we changed the name of the index, and I think it, like, defaults to a certain one. So, if we had that Search goes under search like that. Ah, okay. See if that works. We've still got events. An event count of 0. Let me add my to array back in and see what happens. Uhhuh. Hey! There we go. There it is. This is great. Okay. So, this is great. We've got we've got good stuff happening here. And if we look at anvil, we can see, like, here's the top one that I was looking at, and it shows up. And then we've got, like, a band called anvil. Cool. Okay. So, this is this is doing it, right? This is doing what we wanted. Yeah, and if you wanna try putting in a different search term and see if it brings up something else. Yeah, let's see. Let's just put in a name. Let's put in Anne and see if a name right? So, now we've got, like, people's names and stuff like that, right? So, this is this is I mean, I love this. This is great. 621 instances of Anne. And that all happened really fast. Remember, that had to reach across the cloud to pull back 621 instances. Like this is wow, this is huge. Look how many results we got back. So, yeah, this is really well done. So, then there was also a question in the chat about what happens if we want to write to our database. Mmhmm. So, we can create another function to, like, you know, add a movie, and we can show a write operation and how that works. Let's do it. Okay. So, for this one, I'm gonna pull in the same bit. And I'm also realizing, we would abstract that into a utility function. I don't think we have to worry about that right plow. I'm going to skip it. Instead, I'm going to go here and want to figure out with the event, one of the things that we're gonna want to do is, like, if the event.httpMethod is not POST, we want to return some status code. I don't know. We'll just do a 500 and a body of, like, nope. My favorite error messages, the ones that are completely unhelpful. So, we'll make sure you have to post to write. And then in here, we need to actually do something. So, I've got my database. Mmhmm. And then what? So, then what we can do is just like in the search like when we did the getmovies where it was, you know, collection.find, in our instance, if we want to write a document, it would be collection.insert1 and that's going to insert a document into our database. Okay. So, it's db.collection movies. Do I have to await this one? It does return a promise. You'll await the response. So, I do so, I will await, but I'm gonna chain on this? Mmhmm. Okay. So, it's db.collection. We have our movies collection. Then it'll be .insertOne. Here, we're going to pass in an object of the fields we want to insert. We can insert, again, because it's a Node SQL ideas, we can insert arrays, we can insert objects, we can insert any sort of model we want. We can make up whatever we want in here and say we're going to insert boop true and we're gonna say, like, "hello chat!" And we'll say "ideas" and we'll say, like, "burritos," "hugs" and "pizza." Those are all good ideas. Okay. So, this is completely nonsense. Honestly, the reason I'm doing right now is why people get anxiety about no SQL databases, I think. Right. Is that I am completely not looking at what's happening here. I'm just inserting junk with no respect for the database structure at all. Right. And the thing about, you know, no SQL databases is you can insert this junk, and the MongoDB will happily take it in and post it to that movies collection, and you'll have the data in there, but, you know, we do actually have a schema validation built into MongoDB as well. So, if you wanted to, say, like, hey, you know, this is a schema document in this collection. You can you can specify. So, that if you do try to add in junk, it's going to error out or maybe just send a warning. Sure. Also, additionally, if you really want it to get junk in there, if you have the permission if the user that connect has permission, they can overwrite the schema and say I really want this boop in here, so let's add it. Absolutely. So, is this my result? So, that'll be the result of the operation. Okay. If you want to send back the hold result, it will tell you what is written, where it was written, how long it took. Okay. Yeah. So, let me open up Postman. Let me do that. Where is Postman? Did I actually open it? There it is. And in here, we should be able to post to a let's go to http and we've got a Netlify function. Not now. And we'll say "addmovie," right? So, we don't need to pass anything in yet, so let's just post. And we get back it acknowledged. We got an inserted ID. All good. We're all happy there. So, then, actually, I wonder so, if I go back here now and I search for, like, "pizza," does it show up? Like is it in here somewhere? It might be. It might not. But let's see. I'd be curious to see how quickly the index updates. There it is. There it is. Here's our document. So, like, we wrote it and it's immediately available. And, you know, full chaos mode engaged on this database. So, you know, and this and like, for real, this is one of the reasons why schema validation is a good idea. Is because if I did this and it was a production app and we were, like, trying to display the plot and the title and the genres and then we get to this garbage pile that I created, it would it would either break or we'd need some clientside validation. So, you can there is a way to hold it wrong. And what we've just done is absolutely holding it wrong. (Laughter) Good way to put it. And, you know, another thing we could we could have done in that search aggregation is project only the certain fields that we care about. So that, you know, so that every search you do isn't sending you back all of this data, because in reality you might not care about You know what? How much time do we have? Can we do that in five minutes do you think? Oh, absolutely. Let's clean this thing up and only bring back the title and, like, the short plot. Yep. So, what we would do in that case is we would just add another aggregation stage. So, where we have search, like, that whole object closed. Right there. We would do a project. Like this? So, it would be dollar sign project. And then it would be an object. And this object would be the fields that we want. Either the fields that we want or the fields that we don't want. So, we could say, like, we want the title of the movie. Is it, like, in fields or do I do I do, like, the name of the field and true? You do name of the field and then 1 for true and 0 for false. Okay. So, let's do is there a title There should be a title. Last updated. Am I looking right at this? Title. Title. Oh, title is "pizza." Okay. So, let's get title 1 and plot 1. And this should then change the results here so that we only get the title and the plot? Mmhmm. There we go. Plot 0. And then down at the end, it looks like it found my result, but it did not return it. Right. But if I were to do, like, boop 1, and this one includes boop true, but these ones don't have it, so they don't include it. That's actually pretty great. That's pretty fun. We can just really specify down. And by doing this, we also know that we can we can throw away any results that don't have it. So, I could, for example, just filter right on this and say like, you know, filter if title doesn't exist. Throw it out. We could do that in the aggregation pipeline. So, the cool things about the aggregations is they run on the MongoDB server. So, any aggregation function you write, it's preferable to actually write it in the aggregation, the filtering logic. So, you write it all in the aggregation, and then you format that you expected. I like that. And then it, like, limits you from having to write additional code and kind of marry the serverless logic with the MongoDB logic. You know what? Do you want to walk us through how we could do that? Do we just drop it in right here? So, like, if we wanted to create a different aggregation that, like, using the dollar sign match, like, let's say you wanted Oh, so, it's like a full different thing. Yeah. Okay. Let's not worry about it. We're almost out of time and I want to make sure we don't end up half through an idea at the end. Okay. That makes sense. So, let's do a quick recap of what happened here and how far we got without having to really dig deep into how databases work. Right? So, we started out, we set up a basic site. And we have a search function here that connects to Mongo. And then using that Mongo connection, we look up a list of five movies and send that back. That's what shows up on the homepage here. We get five movies. Excellent. Already, we're happy. We're pulling data from a database to a client side in a secure way where this, you know, the database credentials themselves are protected inside of a serverless function. We're able to run this locally because we're using the Netlify CLI and Netlify delve is pulling in .environmentvariable that's on Netlify so that we can set that up. And then I'm gonna you know what I'm gonna do, actually? Why don't we just deploy this? Do it. Gets git add everything. Git commit and we'll say deploy a working database. We'll push. And then let's open this thing up. And so this will take us over to the site, which is now building. And this should go pretty quick. Elevenity's fast. This will actually deploy the whole site. There is goes. Functions are deployed. Look how freaking fast this all is. 1.4 seconds. Functions, one second. Yeah, I love it when you don't have a big, heavy build process. But anyways, this then brings us back. We've got here's our site running live. Y'all can go play with it right now. And then we can go out here and we can, like, search for a movie. So, we're able to also put together functions and search movie, and let's give it a query of search, and we'll search for "pizza" again. Netlify. Functions. Searchmovies. There we go. And we've got our filtered subset of here's the document. It only has the plot and the title. And then down here at the end, we pulled out did we pull out the boop? I must have because it's not there. Yeah, I think we I did. I pulled it out. So, we've only got the title and the plot there. Great. And then we also have the ability to post. So, if I take this, and let's go back to Postman. I can edit this one. And we will add a movie. Then I can post. And now we'll have oh, I screwed this up. I had double slash. Oh, it still worked anyways. That's a cool Deedoop that it did. Now we have two documents that have our junk that don't include the title and plot that we need. This is all running at production. We've deployed a production app that is able to create data, read data, search data, all of the things that we want, and because, like, you know, somebody can now go if you want, you can go and spam this, right? And because we have the ability to do that aggregation, we can make sure that it's, you know, you have to know what fields we're looking for. You'd have to if this was really production, what we'd also want to do is make sure that we're protecting so that, you know, you have to have a certain level of access. Right. So, we would probably want to have an authorization key or something that we checked for in this one. Where we could check for, like, I don't know, like, if event.headers.Authorization isn't there or, like, doesn't equal whatever, like Right. SECRET_KEY, then we could do something like return 401 and a body of, like, Unauthorized. We have to set that key to make it work. And, you know, we wouldn't want this to be, like, one key. We'd probably want some kind of a lookup for who the authorized user are. So, there is a little bit of authorization stuff that we don't want to deal with. You used to work at Auth0. They're good at that. SuperBass or Onegraph. Make sure users are logged in and check for a valid user and that would prevent the spamming. Because my guess is that knowing the chat, somebody's already spammed up. Chat. Not a single one? Man. I leave you alone for just, like, 200 episodes and y'all go soft on me. I am disappointed. (Laughter) I actually do really appreciate that, chat. But no. This is super fun, right? And this is, I think, the power of this model, is we barely wrote any code, and we're able to get all of this done. Let's look at this. We did here's 35 lines. Here's 46 lines. Here's another 23. And then our front end is 14. So, we're, like, barely 100 lines of code and we were able to write a full search interface. It just feels, like, a superpower. It really feels like being a front end dev with this suite of tools means that we can do so much now. Like we can go so far. And it almost feels like the tables have turned a little bit, right? Like I feel like in the early days of my career, if you were a back end dev, your skills were, like, unlimited. You could do anything. Now I almost feel like it's flipped. Having good front end abilities, being able to build a useable, good looking, functional front end, that's 90% of the battle. You learn those skills, there's so many hosted services and platforms that make databases and serverless and these interactions and authentication, all of those things that are back end concerns, for the vast majority of our ideas for our apps, for our side projects, you're automatically full stack. You don't have to go and do all of you don't have to go and learn that stuff. There's just a thing that you click the button and now you've got that control. Yep. I'm so excited for that world. And the, like, the thing I love about it, too, is like the code that we wrote is it's simple. It's a couple not even a couple hundred lines of code. But this is, you know, minus the authentication piece, it's productionread code. If you were building a bigger application or application for work or trying to get something up, these are the exact queries you would write. There is no a lot of this stuff isn't just throwaway for a demo. You can go and use it, and, you know, build your idea, you know? I think one of the one of the tag lines of MongoDB is kind of working with now is build your future faster. And, you know, I think we kind of showed that. Like you don't need to worry about setting up the database, worrying about where it's hosted, you know? With MongoDB and Netlify serverless functions, you just add that piece of code in and you have a crud back end. You can add search functionality. There is all sorts of other stuff. Like one of the other things that we're not going to have time to get into, but with MongoDB Realm, you can actually take that movies collection and turn it into a GraphQL end point so that all of those documents are you could access them via GraphQL and you don't have to set up the GraphQL server. You just call the endpoint and get the data that you want. Oh, that's so cool. I love that. I mean, yeah, so it sounds like there's a whole world out there of amazing things that we can do, and none of them are asking us to become an expert in a different field. It's mostly a challenge of imagination over a challenge of skill. And that, to me, is the most exciting thing about right now in web dev. Is like if we can imagine it, we can probably plug together a couple of thirdparty services that will do the hard part and just let us do the fun part. I'm so, so excited for all the things that are possible there. Yeah, I love it. I'm super excited. So, with that, I think we're out of time, so, why don't we do this? If somebody wants to go further here, they are going to go to, you know, the MongoDB Atlas page. Which is here. Right? Where are the other resources that people can go and check out? So MongoDB.com/developer is a really good resource for all sorts of tutorials and, you know, we write a lot of content on here on how to get the most out of MongoDB. You know, whether you're building an app with Netlify and it's serverless or you're building a, you know, traditional, you know, back end application, mobile application, whatever you're building. And then, you know, on the developer side, you'll also find the MongoDB community. So, if you have any questions, if you have any feedback, you know, if you just want to talk about MongoDB or how to integrate it with your technology stack, that's another good place to check out and just, you know, come say hi. We're, you know, we have a big Dev Rel team. We're always happy to help and get you over the finish line to build your applications, scale them and have fun doing it, hopefully. Absolutely. And, you know, if you want to connect directly, you can always go find Ado on Twitter. So, make sure you go get that follow in. Let's see how good the chat did today. Did anybody go and follow you? Did we get anybody? Anybody in there? I think we got a couple. Okay. So, we've got that. Also, as always, we've had a live captioner with us. We've got Jordan here today from White Coat Captioning. Thank you so much, Jordan. And that's made possible through our sponsors, Netlify, Fauna, Hasura, Auth0. All kicking in to make this show more accessible. While you're at the site, make sure you go and check out the schedule. We've got so much fun stuff coming up I can't even handle it. So, tomorrow's stream, unfortunately, we had to reschedule that one. So, I'm going to do something. I don't know. Maybe I'll bring a surprise guest. Maybe we'll do some solo. Either way, it's going to be great. Make sure you tune in next Tuesday. We've got Brandon Roberts coming on. We're going to talk about Reactive State Management. That's going to be fun. StepZen and turning any source into GraphQL. Look at these amazing faces. All of these wonderful teachers are going to come and teach us things on Learn With Jason. I cannot wait. I even have more that I have to get listed on the site. I'm just so slow. Personally, I'm very excited for Lynne to come online. She's a good friend. Her UI and UX design skills are really, really amazing. Super excited for this one. Marie Poulln we're going to talk about Notion and how do you keep track of your teams and what everybody' working on. Especially in a remote world the postpanacotta era, remote management skills, this one is going to be so much fun. Grid. I'm so excited. This is going to be so incredible. Make sure you can add that. Get on the Google Calendar here. It's not a notification. Doesn't put you on an email list. It's just so you can make sure you don't miss an episode. With that, Ado, thanks so much for spending time. Any parting words for the chat? Thank you all tuning in. If you want to give MongoDB Atlas a tree, please do. We have a pretty good free tier. Find me on Twitter. As always, Jason, it was an absolute pleasure spending 90 minutes with you and teaching you something new. Yeah, absolutely. So, we're going to go and harass Alex. Say hello. Tell him I sent you. We will see you next time. Thank